# 软件工程与计算Ⅰ -编程之前

> 本部分内容对应于PPT 01-06

## 编程语言概述

这部分内容已经大量包括在名词解释那个文档中，因而此处略去了大部分内容。

50年代：机器语言

60年代：汇编语言

> - 1968 – Logo
>
> - 1969 – B (forerunner to C)
> - 1970 – Pascal
> - 1970 – Forth
> - 1972 – C-（结构化编程范式）
> - 1972 – Smalltalk（面向对象编程范式）
> - 1972 – Prolog（逻辑编程范式）
> - 1975 – Scheme（函数式编程范式）
> - 1978 – SQL （标准查询语言）
> - 1980 – C++ (原C with classes, 1983改用现名)
> - 1984 – MATLAB
> - 1986 – Objective-C
> - 1988 – Wolfram Language
> - 1990 – Haskell
> - 1991 – Python
> - 1991 – Visual Basic
> - 1993 – Ruby
> - 1995 – Java

后面的应该也太新了，就不管了。老师上课还提到了Oracle和Google的斗争：抄API到底算不算侵权？

## 分解与抽象

编程的典型场景 — 数据处理：输入处理输出

### 可计算性

> 此处的可计算性仅仅考虑在理论上是否可以计算而不考虑现实中成本的制约

莱布尼兹→推理演算，布尔→布尔代数，弗雷格→数理逻辑，康托尔→⽆穷集和对⻆线法

#### 罗素悖论（关联希尔伯特判定问题）

理发师悖论：A={x|x ∉ x}时，A∈A是否成立？

#### 停机问题

不存在这样⼀个程序（算法），它能够计算任何程序（算法）在给定输⼊上是否会结束（停机）。

只要有⼀个数学问题可以被证明在算法上试不可解的，那么判定问题本身就必定不可解。

- “找到⼀种算法，判定⼀个给定的⾃然数是否属于集合D。”这个问题就是⼀个不可解问题的例⼦。
-  假设存在这样的算法，则存在这样的图灵机
-  把输⼊的数属于D ，那么按以前运转，否则将永远右移（2个五元组即可表达）
-  新机器的停机集合就是D。然⽽这时不可能的。

对⻆线⽅法将允许我们构造出⼀个与图灵机的任何停机集合都不同的⾃然数集合。

> 证明实数不可数的过程也类似于此。

```c++
bool God_algo(char* program, char* input){
	if(<program> halts on <input>){return true;}
	else{return false;}}
```

```c++
bool Satan_algo(char* program){
	if( God_algo(program, program) ){
		while(1); // loop forever!
		return false; // can never get here!}
	else{
	return true;}}
```

- Satan_algo(Satan_algo)能够停机 => 它不能停机

- Satan_algo(Satan_algo)不能停机 => 它能够停机

#### 哥德尔不完备性定理

> 哥德尔：弗雷格的规则是完备的。

任何相容的形式系统，只要蕴涵⽪亚诺算术公理，就可以在其中构造在体系中既不能证明也不能否证的命题（即体系是不完备的）

任何相容的形式系统，只要蕴涵⽪亚诺算术公理，它就不能⽤于证明它本身的相容性。

> Trick：你可以用外部的形式系统证明它的相容性
>
> 只需在假定的形式系统T内表达出⼀个为真但⽆法在T内推导出（证明）的命题。P：P不可在系统T内证明→P为真但⽆法在T内推导出来→T不可以证明出P （存在不能证明的）

#### 邱奇-图灵论题

- ⼀台图灵机单凭⾃身就可以完成任何图灵机可能做到的任何事情。

- 图灵提出了机器、程序、数据观念的融合与替换。
- 任何有对应算法的函数都是可计算的。
- All three computational processes (recursion, the λ-calculus, and the Turing machine) were shown to be equivalent.

##### 非形式化

> - i) 1是⾃然数；
>
> - ii) 每⼀个确定的⾃然数a，都有⼀个确定的后继数a' ，a' 也是⾃然数（⼀个数的后继数就是紧接在这个数后⾯的数）；
>
> - iii) 如果⾃然数b、c的后继数都是⾃然数a，那么b = c；
>
> - iv) 1不是任何⾃然数的后继数；
>
> - v) 任意关于⾃然数的命题，如果证明了它对⾃然数1是对的，⼜假定它对⾃然数n为真时，可以证它对n' 也真，那么，命题对所有⾃然数都真。（这条公理保证了数学归纳法的正确性）

> 若将0也视作⾃然数，则公理中的1要换成0。

##### 形式化

> 三元组（X, x, f）
>
> • X是⼀集合，x为X中⼀元素，f是X到⾃身的映射。
>
> • x不在f的值域内。（对应上⾯的公理4）
>
> • f为⼀单射。（对应上⾯的公理3）
>
> • 若A为X的⼦集并满⾜：
>
> • x属于A,且若a属于A，则f（a） 亦属于A，则A = X。

⼀切初等数论中的函数都可以由原始递归式作出，即都是原始递归函数。

μ-递归函数以后的数论内容此处略去。

##### 图灵机

|                                                              |
| ------------------------------------------------------------ |
| ![im](https://oss.ydjsir.com.cn/img/turingMachine.png) |

这部分内容如果想深入了解的话可以好好看看离散数学教材的第十一章：有限状态机。

下面是一个`f(x) = 2^x` 的函数的图灵机表达形式。这里用了五元组的表达形式，而略去了q~reject~ 和 q~accept~ 。

|                                                              |
| ------------------------------------------------------------ |
| ![](https://oss.ydjsir.com.cn/img/image-20200820195546105.png) |

###### 约定

- 1.开始时，纸带上只有⼀连续的⽅格串上放⼊相应于x的⼆进制值的符号，其余⽅格均为空⽩（⽤B表示）；
- 2.读写头⼀开始位于表示x的⽅格的最左边⼀位所在⽅格；
- 3.停机时，纸带上⾮空⽅格串所组成的⼆进制值即为所求结果。
###### 程序的实现思想：
  我们知道，在⼆进制表示下，只要在原数后⾯添上⼀个0，就是原来的数乘以⼆。根据这个思想，我们每次写⼀个0，同时原数减⼀，直到原数减为0，再在所写的0前⾯添加上⼀个1，就能得出所求函数的答案了。
  ###### 状态含义：
  • q1:起始状态；忽略前导0，寻找该数的真正起始位置，如果出现_00……00_0…… 00的情况，则转⼊q7；

  • q2:读写头向右移动直到遇到空格；

  • q3: 此空格后0的数⽬加1；

  • q4:回到原来数的最右端；

  • q5: 该数减1；

  • q6: 回到数的开头，转⼊q1；

  • q7:结束状态。

  可以看到，q1到q7,7个状态，相当于⼀个个标志，而整个程序也相当于是⼀句句的goto语句。

这里可以再补充一个例子。这个例子是`f(x) = x + 1` 。

| 图灵机对应五元组 | 备注                                         |
| ---------------- | -------------------------------------------- |
| q1,0,1,l,q2      | 末尾是0的话，就把末尾改为1                   |
| q1,1,0,l,q3      | 末尾是1的话，就把末尾改为0，并进入q2进位模式 |
| q1,b,b,n,q4      | 如果根本没有读到数字，直接跳到q4，结束循环   |
| q2,0,0,l,q2      | 只要当前不为空，读取头就继续左移             |
| q2,1,1,l,q2      | 只要当前不为空，读取头就继续左移             |
| q2,b,b,n,q4      | 一旦读取到空内容，直接跳到q4，结束循环       |
| q3,0,1,l,q2      | 进位后若不需要继续进位，跳到q2               |
| q3,1,0,l,q3      | 进位后仍需继续进位                           |
| q3,b,b,n,q4      | 一旦读取到空内容，直接跳到q4，结束循环       |

> 读写头⼀开始位于数据最右边⼀位，b表示空格，q1为初始状态，q4为结束状态。q2为不进位情况下读取头不断左移的状态，q3是进位状态。可以回顾计基中的全加法器，这两个是类似的。

|                                                              |
| ------------------------------------------------------------ |
| ![image-20200820201202995](https://oss.ydjsir.com.cn/img/image-20200820201202995.png) |

 图灵机 对应 寄存器机部分内容此处从略。

|                                                              |
| ------------------------------------------------------------ |
| ![image-20200820202212310](https://oss.ydjsir.com.cn/img/image-20200820202212310.png) |

对每一个图灵机T而言，一定有一个寄存器机器R和T具有相同的行为，且这个寄存器机器最少包括两个寄存器和两条指令。

## Lambda演算

这部分内容就没有比老师给的那两个文档讲的更好的了，建议细看，这里只是一些漏掉的点。PPT基本就是复制粘贴，还是看视频好懂。

> BNF记号与上下文无关语法的详细内容可以在离散数学教材中获得参考。

形式化地，我们从⼀个标识符（identifier）的可数⽆穷集合开始，⽐如{a, b, c, ..., x, y, z, x1, x2, ...}，则所有的lambda表达式可以通过下述以BNF范式表达的上下⽂⽆关⽂法描述：

> -  <表达式> ::= <标识符>
> -  <表达式> ::=(λ<标识符> .<表达式>)
> -  <表达式> ::=(<表达式> <表达式>)

头两条规则⽤来⽣成函数，⽽第三条描述了函数是如何作⽤在参数上的。

## 函数式编程范式

> 在函数式编程中，⼀个程序会被看作是⼀个⽆状态的函数计算的序列。
>
> 注意！Scheme采用波兰表达式，也就是前缀形式！函数式编程是无状态的！Scheme的很多内容都可以无缝切换到λ的内容中，因而显得格外重要！

### 避免过程和数据的重复

重点题目：换零钱：将1美元换成半美元、四分之⼀美元、10美分、5美分、1美分总共有多少种换法？

```scheme
(define (count-change amount)(cc amount 5));总共可供兑换的货币的种数

(define (cc amount kinds-of-coins)
	(cond ((= amount 0) 1)((or (< amount 0) (= kinds-of-coins 0)) 0)
	(else (+ (cc amount (- kinds-of-coins 1));把一种货币的情况换完了，就把总的可兑换的钱币的种数减去1，且先从半美元换起
		(cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
(cond ((= kinds-of-coins 1) 1) ((= kinds-of-coins 2) 5) ((= kinds-of-coins 3) 10) ((= kinds-of-coins 4) 25) ((= kinds-of-coins 5) 50)));分别确定不同种硬币数量下应该兑换的货币
```

### 高阶函数

过程作为参数，也是⼀种抽象。在下面这个广义求和的函数中，形参是函数。此处可以类比C++中的template和JAVA中的泛型。

```scheme
(define ( <name> a b)
	(if (> a b)
		0
		(+ (<term> a) (<name>(<next> a) b))));下文中出现的sum就是将这个例子中的<name>换为sum后的实例
```

```scheme
(define (identity x) x);求a到b范围内整数的和
(define (inc x) (+ n 1))
(define ( sum-integer a b)
	(sum identity a inc b))
```

```scheme
(define (f x y)
	(let ((a (+ 1 (* x y)));let定义的变量的值仅在当前表达式内部有效
		(b (- 1 y)))
	(+ (* x (square a))
		(* y b)
		(* a b))))
```

Scheme中**关键字**、**函数**、**变量**之间的界线很模糊，事实上，它们都可以理解为过程(函数)。

有理数、链表和树这样的具有层次性结构的数据结构等。比如说下面的数值树（返回一颗每个节点的权重都乘上特定因数的新树）

```scheme
(define (scale-tree tree factor)
	(cond ((null? tree) null)
		((not (pair? tree)) (* tree factor))
		(else (cons (scale-tree (car tree) factor)
			(scale-tree (cdr tree) factor)))))
```

### 信号流（枚举器+过滤器+映射+累积器）与JAVA8中的SteamAPI（WarmUp中有一题）

```scheme
(define (map proc items)
	(if (null? items);枚举器器，一路迭代直到最后一个为空
		nil
		(cons (proc (car items));映射
			(map proc (cdr items)))));累积器
```

Python中的函数式编程：`map` , `fliter` , 和`reduce` 。

```python
# 下面的实例大量采用了短路算法。这样的算法在C/C++中很常用。大意就是在A and B中，如果A对，自然会去执行B看B对不对，这就相当于一个if(A)，A or B中则是A不对的时候才会执行B看B对不对
square = lambda x : x * x
for x in [1,2,3,4,5]: square(x)

while_FP = lambda: <condition> and (while_block() or while_FP())# while的全新版本
```

Java中的函数式编程（WarmUp - Stream）

```java
// 使用函数式范式实现返回首字母大写的字符串
	public static String getNamesStringFunctionally(List<String> nameList) {
		List<String> results = nameList.stream()
				.filter(strings -> strings.length() > 1)
				.map(strings -> strings.substring(0, 1).toUpperCase() + strings.substring(1))
				.collect(toList());
		return String.join(",", results);
	}
```

### 函数式编程范式的特点

- 函数被当作头等公⺠，意味着函数可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中；
- 影响函数返回值的唯⼀因素就是它的参数；
- 在函数式编程中，函数就是基础元素，可以完成⼏乎所有的操作，哪怕是最简单的计算，也是⽤函数来完成的，⽽我们平时在其他类型中所理解的变量（ 可修改，往往⽤来保存状态 ）在函数式编程中，是不可修改的，这意味着状态（ State ）不能保存在变量中，⽽事实上函数式编程是使⽤函数参数来保存状态，最好的例⼦便是递归。
- 基于它的无状态性，它对并发性有更好的支持。
- 它可以更好地支持惰性求值这一特性，省去许多无谓的运算。

它可以快速且简单地实现函数封装。

### 编译器的工序

#### • 词法分析-词语分割

#### • 语法分析-语法树

#### • 语义分析

⼀个扩展的解析树，表示程序的句法结构，同时还包含了标示符的类型、标示符在哪⾥声明等信息。

#### • 中间代码⽣成

#### • 代码优化

|                  |                |
| ---------------- | -------------- |
| 删除公共⼦表达式 | 复写传播       |
| 代码外提         | 删除⽆⽤代码   |
| 强度削弱         | 常量合并       |
| 变换循环控制条件 | 代码移动       |
| 合并已知变量     | 内联函数的调⽤ |

#### • ⽬标代码⽣成

### 编译器的现实考量

实现有两种，逻辑实现与物理实现。

- 复杂性与规模
- 逻辑与物理
- 时间与空间

计算机的实现不一定是perfect的。有的时候，对于一些混沌的世界，我们只能选择用拟合的方式去估算；另一方面，现实世界很多东西是连续的，然而，现代计算机的01世界中事物必然是离散的，这就是一个很严重的矛盾。比如说，浮点数的相等，我们只能采取保留精度误差范围内相等的方式。

> JAVA中你可以写`Double.equals(d1, d2)`

### 静态与动态

| 静态     | 动态   |
| -------- | ------ |
| 代码     | 执行   |
| 存储     | 处理器 |
| 数据结构 | 算法   |

就目前来看，计算资源相较于存储资源更为昂贵。

| 处理器   | 存储     |
| -------- | -------- |
| 主动     | 被动     |
| 计算速度 | 存储空间 |
| 快       | 大       |

### 算法驱动和数据驱动

#### 算法驱动
• 只在需要f(x)的值的时候，通过计算得到。
#### 数据驱动
• 先通过计算，保存所有x对应的f(x)值，需要计算的时候直接访问。

以上两点体现的是优先使用算力还是优先使用存储空间之间的博弈。

### 证明程序的正确性

#### Edsger W. Dijkstra

- 枚举-Enumeration

- 推导-Mathematical induction

- 抽象-Abstraction

#### C. A. R. HOARE

- 公理化证明-Axioms proof